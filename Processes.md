# Processes
    Processes are the programs that are running on your machine. 
    They are managed by the kernel and each process has an ID associated with it called the process ID (PID). 
    This PID is assigned in the order that processes are created.

    PID: Process ID
    TTY: Controlling terminal associated with the process (we'll go in detail about this later)
    STAT: Process status code
    TIME: Total CPU usage time
    CMD: Name of executable/command

    $ ps aux
    
    The a displays all processes running, including the ones being ran by other users. The u shows more details about the processes. 
    And finally the x lists all processes that don't have a TTY associated with it, these programs will show a ? in the TTY field, 
    they are most common in daemon processes that launch as part of the system startup.

    You'll notice you're seeing a lot more fields now, no need to memorize them all, in a later course on advanced processes, 
    we'll go over some of these again:

    USER: The effective user (the one whose access we are using)
    PID: Process ID
    %CPU: CPU time used divided by the time the process has been running
    %MEM: Ratio of the process's resident set size to the physical memory on the machine
    VSZ: Virtual memory usage of the entire process
    RSS: Resident set size, the non-swapped physical memory that a task has used
    TTY: Controlling terminal associated with the process
    STAT: Process status code
    START: Start time of the process
    TIME: Total CPU usage time
    COMMAND: Name of executable/command


## process creation

    When a new process is created, an existing process basically clones itself using something called the fork system call (system calls will be discussed very far into the future). 
    The fork system call creates a mostly identical child process, this child process takes on a new process ID (PID) 
    and the original process becomes its parent process and has something called a parent process ID PPID. 
    Afterwards, the child process can either continue to use the same program its parent was using before or more often use the execve system call to 
    launch up a new program. This system call destroys the memory management that the kernel put into place for that process and sets up new ones for the new program.

    $ ps l
    The l option gives us a "long format" or even more detailed view of our running processes. You'll see a column labelled PPID, this is the parent ID


    when the system boots up, the kernels creates a process called init, it has a PID of 1. 
    The init process can't be terminated unless the system shuts down. It runs with root privileges and runs many processes that keep the system running.


    A process can exit using the _exit system call, this will free up the resources that process was using for reallocation. So when a process is ready to terminate, 
    it lets the kernel know why it's terminating with something called a termination status. Most commonly a status of 0 means that the process succeeded. 
    However, that's not enough to completely terminate a process. The parent process has to acknowledge the termination of the child process 
    by using the wait system call and what this does is it checks the termination status of the child process.
## orphan processes
    When a parent process dies before a child process, the kernel knows that it's not going to get a wait call, 
    so instead it makes these processes "orphans" and puts them under the care of init (remember mother of all processes). 
    Init will eventually perform the wait system call for these orphans so they can die.

## zombie process
    What happens when a child terminates and the parent process hasn't called wait yet? 
    We still want to be able to see how a child process terminated, so even though the child process finished,
    the kernel turns the child process into a zombie process. 
    The resources the child process used are still freed up for other processes, however there is still an entry in the 
    process table for this zombie. Zombie processes also cannot be killed, since they are technically "dead", 
    so you can't use signals to kill them. Eventually if the parent process calls the wait system call, 
    the zombie will disappear, this is known as "reaping". If the parent doesn't perform a wait call, 
    init will adopt the zombie and automatically perform wait and remove the zombie. 

## signal process
    When a signal is generated by some event, it's then delivered to a process, it's considered in a pending state until it's delivered. 
    When the process is ran, the signal will be delivered. 
    However, processes have signal masks and they can set signal delivery to be blocked if specified. 
    When a signal is delivered, a process can do a multitude of things:

    Ignore the signal
    "Catch" the signal and perform a specific handler routine
    Process can be terminated, as opposed to the normal exit system call
    Block the signal, depending on the signal mask 

    Each signal is defined by integers with symbolic names that are in the form of SIGxxx. Some of the most common signals are:

    SIGHUP or HUP or 1: Hangup
    SIGINT or INT or 2: Interrupt
    SIGKILL or KILL or 9: Kill
    SIGSEGV or SEGV or 11: Segmentation fault
    SIGTERM or TERM or 15: Software termination
    SIGSTOP or STOP: Stop
    Some signals are unblockable, one example is the SIGKILL signal. The KILL signal destroys the process.
    A high number means the process is nice and has a lower priority for the CPU and a low or negative number 
    means the process is not very nice and it wants to get as much of the CPU as possible.
    The nice command is used to set priority for a new process. The renice command is used to set priority on an existing process.
    eg:- nice -n 5 apt upgrade
        renice 10 -p 3245

        R: running or runnable, it is just waiting for the CPU to process it
        S: Interruptible sleep, waiting for an event to complete, such as input from the terminal
        D: Uninterruptible sleep, processes that cannot be killed or interrupted with a signal, usually to make them go away you have to reboot or fix the issue
        Z: Zombie, we discussed in a previous lesson that zombies are terminated processes that are waiting to have their statuses collected
        T: Stopped, a process that has been suspended/stopped

    Process information is stored in a special filesystem known as the /proc filesystem.

    $ ls /proc

## Job Control
    Appending an ampersand (&) to the command will run it in the background so you can still use your shell. Let's see an example:

    $ sleep 1000 &
    Now you can view the jobs you just sent to the background.

    $ jobs
    If you already ran a job and want to send it to the background, you don't have to terminate it 
    and start over again. First suspend the job with Ctrl-Z, then run the bg command to send it to the background.
    To move a job out of the background just specify the job ID you want. If you run fg without any options, it will bring back the most recent background job (the job with the + sign next to it)

    $ fg %1
